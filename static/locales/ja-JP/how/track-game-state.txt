ゲームの状態を追跡する

ほとんどのゲームでは、ゲームの進行中にポイント、プレーヤーの位置、その他の詳細など、複数の要素を追跡します。何らかの入力があるたびに状態が変化し、それに応じて新しい出力を表示します。

どのゲームにも共通する一般的なパターンは次の 3 つです。

• ゲーム状態データ構造を定義し、ゲーム状態をすべて保存する• 新しい入力があるたびに、以前のゲーム状態に基づいて新しいゲーム状態を作成する反応を定義します。• 作る @Stage  と  @Group  そして  @Phrase ゲームの状態を表示する

たとえば、テキスト ボックスに秘密の単語を入力し、秘密の単語が推測されるたびにポイントを獲得するという単純なゲームを想像してみましょう。

\•Game(secrets•[''] points•#)
state: Game(['猫' '犬'] 0) … state.secrets.has(Chat()) … state.points:state.points + 1
Stage(state.points = state.secrets.length() ? [Phrase("あなたの勝ちです！")] [
			Group(Stack() [
					Phrase("私の秘密の言葉を推測してください")
					Phrase(`\state.secrets.length() - state.points\さらなる秘密`)
				])
		])\

これを詳しく見てみましょう。

• 最初の行、\•Game(secrets•[''] points•#)\言う、/というデータ構造を作成します\Game\秘密とポイントのリストを保存する/• 2行目には/ゲームは秘密のリストと0ポイントで始まります。\Chat\変更後、入力した単語が秘密のリストにある場合は、ポイントが1つ増加した新しいゲーム状態を作成します。/。• プログラムが再評価されるたびに（\Chat\変化があった場合、ステージを表示します。ポイント数がシークレットの数と等しい場合は、勝利ステージを表示します。そうでない場合は、プロンプトと残りのシークレットの数を表示します。

この例にはいくつか問題があります。

• 秘密の言葉を複数回推測すると、より多くのポイントを獲得できます。ゲームの状態では推測された単語も記憶する必要があるため、各単語は2回だけカウントされます。• プレイヤーが複数の単語を入力した場合、それはカウントされますか?

より洗練されたゲーム状態とゲームの更新は、これらのケースを処理するのに役立ちます。

track-points