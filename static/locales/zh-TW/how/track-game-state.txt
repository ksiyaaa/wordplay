追蹤遊戲狀態

大多數遊戲在遊戲進行過程中都會追蹤多項事物：分數、玩家位置和其他細節都是關鍵。每次有輸入時，狀態就會發生變化，然後我們希望顯示新的輸出作為回應。

任何遊戲的通用模式都會做三件事：

• 定義一個遊戲狀態資料結構，用於儲存所有遊戲狀態• 定義一個反應，當有新的輸入時，根據先前的遊戲狀態創建新的遊戲狀態• 製作 @Stage  和 @Group  和 @Phrase 顯示遊戲狀態

例如，讓我們想像一個簡單的遊戲，其中需要在文字框中輸入秘密單詞，並且每次猜出一個秘密單詞時都會獲得一分：

\•Game(secrets•[''] points•#)
state: Game(['貓' '狗'] 0) … state.secrets.has(Chat()) … state.points:state.points + 1
Stage(state.points = state.secrets.length() ? [Phrase("你贏了！")] [
			Group(Stack() [
					Phrase("猜猜我的秘密")
					Phrase(`\state.secrets.length() - state.points\更多秘密`)
				])
		])\

讓我們來分析一下。

• 第一行，\•Game(secrets•[''] points•#)\說，/製作一個名為\Game\儲存秘密和點的列表/• 第二行說/遊戲狀態以秘密清單和零分開始。每次\Chat\改變，如果輸入的單字在秘密清單中，則創建一個新的遊戲狀態，並將分數增加一/。• 每次程序重新評估時（當\Chat\（根據變化），顯示一個階段。如果分數等於秘密數量，則顯示獲勝階段。如果不相等，則顯示提示和剩餘秘密數量。

這個例子存在一些問題：

• 如果他們多次猜出同一個秘密單詞，就能獲得更多分數！我們的遊戲狀態可能還需要記住猜對的內容，所以每個單字只計算兩次。• 若玩家輸入多個單字，是否該計算在內？

更複雜的遊戲狀態和遊戲更新將幫助我們處理這些情況。

track-points