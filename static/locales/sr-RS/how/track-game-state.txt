Пратите стање игре

Већина игара прати више ствари како игра напредује: поени, позиције играча и други детаљи су кључни.Сваки пут када постоји неки улаз, то стање се мења, а затим желимо да прикажемо нови излаз као одговор.

Општи образац за било коју игру ради три ствари:

• Дефинишите структуру података о стању игре, да бисте сачували целокупно стање игре• Дефинишите реакцију која ствара ново стање игре на основу претходног стања игре кад год постоји нови улаз• Направите @Stage са @Group и @Phrase да се прикаже стање игре

На пример, замислимо једноставну игру која укључује куцање тајних речи у поље за текст и добијање поена сваки пут када се погоди тајна реч:

\•Game(secrets•[''] points•#)
state: Game(['мачка' 'пас'] 0) … state.secrets.has(Chat()) … state.points:state.points + 1
Stage(state.points = state.secrets.length() ? [Phrase("победио си!")] [
			Group(Stack() [
					Phrase("Погоди моје тајне речи")
					Phrase(`\state.secrets.length() - state.points\више тајни`)
				])
		])\

Хајде да ово разложимо.

• Први ред,\•Game(secrets•[''] points•#)\каже,/Направите структуру података под називом\Game\који чува листу тајни и поена/• Други ред каже/Стање игре почиње са листом тајни и нула поена. Сваки пут када\Chat\промене, ако је унета реч на листи тајни, онда направите ново стање игре са повећаним поенима за један/.• Сваки пут када програм поново процењује (када\Chat\промене), прикажите фазу. Ако је број поена једнак броју тајни, приказује се победничка фаза. Ако није, прикажите упит и број преосталих тајни.

Овај пример има неке проблеме:

• Ако погоде тајну реч више пута, добијају више поена! Наше стање у игри можда ће морати да запамти и шта је погодено, тако да се свака реч рачуна само два пута.• Ако играч унесе више речи, да ли би то требало да се рачуна?

Софистициранија стања игре и ажурирања игре би нам помогла да се носимо са овим случајевима.

track-points