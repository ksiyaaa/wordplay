跟踪游戏状态

大多数游戏在游戏进行过程中都会追踪多项事物：分数、玩家位置和其他细节都是关键。每次有输入时，状态就会发生变化，然后我们希望显示新的输出作为响应。

任何游戏的通用模式都会做三件事：

• 定义一个游戏状态数据结构，用于存储所有游戏状态• 定义一个反应，当有新的输入时，根据先前的游戏状态创建新的游戏状态• 制作 @Stage  和  @Group  和  @Phrase 显示游戏状态

例如，让我们想象一个简单的游戏，其中需要在文本框中输入秘密单词，并且每次猜出一个秘密单词时都会获得一分：

\•Game(secrets•[''] points•#)
state: Game(['猫' '狗'] 0) … state.secrets.has(Chat()) … state.points:state.points + 1
Stage(state.points = state.secrets.length() ? [Phrase("你赢了！")] [
			Group(Stack() [
					Phrase("猜猜我的秘密")
					Phrase(`\state.secrets.length() - state.points\更多秘密`)
				])
		])\

让我们来分析一下。

• 第一行，\•Game(secrets•[''] points•#)\说，/制作一个名为\Game\存储秘密和点的列表/• 第二行说/游戏状态以秘密列表和零分开始。每次\Chat\改变，如果输入的单词在秘密列表中，则创建一个新的游戏状态，并将分数增加一/。• 每次程序重新评估时（当\Chat\（根据变化），显示一个阶段。如果分数等于秘密数量，则显示获胜阶段。如果不相等，则显示提示和剩余秘密数量。

这个例子存在一些问题：

• 如果他们多次猜出同一个秘密单词，就能获得更多分数！我们的游戏状态可能还需要记住猜对的内容，所以每个单词只计算两次。• 如果玩家输入多个单词，是否应该计算在内？

更复杂的游戏状态和游戏更新将帮助我们处理这些情况。

track-points